{"./":{"url":"./","title":"Introduction","keywords":"","body":"README.md ​ 该文档为记录个人学习过程中遇到的问题、总结的经验、使用过的优秀的工具插件等等。 合格的工程师 必要的单元测试 必要的压力测试 良好的代码规范 必要的项目文档 必要的代码审核(CodeReview) 知识源泉 大佬博客 大厂博客 我的书单 读书笔记 DevOps CI CD 计算机科学 堆/栈 Mac操作指南 常规Mac操作 终端操作 工具操作 git gitbook Goland Markdown SublimeText 单元测试 单元测试文档 个人网站 个人网站想法 工作遇到的 Redis锁 关注开源社区 关注底层知识 数据结构和算法、计算机科学 单元测试 性能分析：PProf 性能提升 内置库 context sync.pool runtime atomic.value Todo [ ] CI / CD [ ] API 监控 [ ] readme win10激活 下载工具pandownload+pansou 静态博客 github page + hugo (基于golang开发) golang学习，fork的golang开发者路线， 源码赏析，我发现读别人的项目就跟欣赏优秀的文章一样，自己能收获许多，多是架构设计方面的收获。以后要多借鉴优秀的项目的设计。 神级golang开源项目 使用hugo创建了项目 使用到的主题: allinone 所根据的教程: hugo 创建了google analysis 跟踪 golang 设计模式 hugo主题 解决静态文件加载路径不对的问题思路 hugo建站全流程 golang内存管理 9月学习计划。golang底层专栏、面向信仰编程 操作系统：cyc2018 软件工程：软件工程之美 抢票神器：bypass.cn "},"engineer/unitTest.html":{"url":"engineer/unitTest.html","title":"必要的单元测试","keywords":"","body":"必要的测试 开发任务 = 功能逻辑编码 + 单元测试 什么是测试？ 测试，即对完成的工作进行功能正确性检验的活动。该检验通过对被测对象提供合法(正常情况，极端情况，边界情况)以及不合法的输入(所有可能发生的情况)，并通过比较预期输出与实际输出内容是否相等或者在误差范围内，来达到检验正确性的目的。 为什么要进行测试？ 为了保证我们写的代码一直(包括初次完成以及之后的所有修改)是功能正确的。一个函数对应一个功能，所以当其对应的测试代码完成后，所有情况的输入都有了预期的输出，当对代码进行改动后，如果得到的输出不符合测试代码的预期输出，那么说明此次代码的改动出了问题。当然，也为别人可以很快的通过测试代码了解代码的逻辑以及实现的功能。尽早发现问题、bug 测试有哪些分类？ 按不同情况来划分，软件测试分为很多类。按开发阶段划分，可分为：单元测试、集成测试、系统测试、验收测试。 单元测试 即对系统中的最小组成单元进行的测试 哪些代码需要进行单元测试？ 逻辑复杂的 容易出错的 不易理解的，即过段时间自己也会忘记的，看不懂的，单元测试代码有助于理解代码的功能和需求 公共代码。大家都会调用的公共方法类 核心业务代码。 单元测试用例有哪些情况呢？ 正常测试，即走最多数情况的正常测试 错误测试，即会令程序出现错误的分支 分支测试，即多个分支的情况都要考虑到的测试 边界值测试，即考虑输入的边界值的测试 单元测试的三R原则 Responsible(负责):谁开发谁测试，在哪开发就在哪测试 Reliable(可靠性):测试用例要可靠 Repeative(可复用):所有单元测试都要可重复运行，这样就可以进行回归测试、覆盖率统计。 单元测试要完成哪些任务呢？即怎么才是一个合格的单元测试呢？ 所有独立执行通路测试：保证每一行代码，每个分支都经过了测试 代码覆盖率 语句覆盖：保证每一条语句都执行到了 判定(分支)覆盖：保证每一个分支都覆盖到 条件覆盖：保证每一个条件都覆盖到(true/false) 路径：保证每一个路径都覆盖到 各条错误处理条件通路测试：保证每一个异常都经过测试 边界条件测试 变量没有赋值( 值为nil ) 变量数数值 正常边界：最小值、最大值、无穷大 临近边界：比最小值大1、比最大值小1 溢出边界：比最大值大1、比最小值小1 变量是字符串 空字符串 引用字符串边界索引 str [ len( str ) + 1 ] 变量有规律 独立性，测试用例的的数据不依赖其他输出，减少相互影响。 单元测试用例编写技巧 结果的预知性：对于没有准确结果的函数，不必写测试。 使用断言assert，而不是fmt.Println() 再去控制台对比结果 考虑负面场景，即考虑系统是否可以处理无效数据 测试中的fake、mock、stub。 Stub：当某个对象需要从数据库中抓取数据的时候，直接返回预定义的数据，而不是真的去查库获取。 Mock：当我们不希望真的调用生产环境下的代码或者在测验中难以验证真实代码执行效果的时候，可以用Mock来代替那些真实的对象。例子为，当我们进行广告匹配上报的时候，测试阶段是无法验证其结果的，而更多关注上报这一步是否被执行了，可以Mock渠道的返回结果。 Fake: 是那些包含了生产环境下具体实现的简化版本的对象。去除多余内容，只关心核心逻辑。例如不关注对象的数据库存储过程，将其存储到内存中，简化步骤，验证其接口实现是否正确即可。而stub关注输入输出，伪造一个输入，看输出是否符合预期，所以比较适合于Query 代码提交之前进行覆盖率统计，阈值为90%。提交代码，自动会触发UT, 运行程序内的单元测试，超过阈值即可 完整的开发流程：需求预估、评审——概要设计与评审——测试用例撰写与评审——开发——测试与修复bug——发布——版本、项目过程总结 Mock： ​ A函数需要B函数提供的数据，测试A函数的时候我们只想测试A函数，不想调用B，这时候就需要我们自己提供B函数生成的数据。这叫做mock。 数据的隔离： ​ 我们需要把表的数据为每个存储过程做隔离，如果测试用例使用的数据相互之间关联，恐怕会天下大乱，因为在一般情况下，单元测试用例的运行顺序都是随机的，如果单元测试使用的数据有关联，很有可能两次运行结果也是随机的 流程：先测试设计，再进行开发。Test Driven Development(TDD) 好处： 一开始就从被使用的角度思考，避免开发了半天最终发现根本就不需要的情况 首先写出测试，便于接口各方尽早达成共识，并在开发过程中保持 先写测试并且执行验证，这时测试必然是失败的。然后在修改了实现代码后再次验证测试成功。这样既验证了实现的行为按照预期改变，也验证了测试确实反映出了系统的行为变化。 有利于把待解决问题具体化，并进行分解。避免分析麻痹。 保证开发中每时每刻代码都是可验证的。 坏处： 如果确信目前写的代码不需要很高质量，TDD有可能过分严格导致增加工作量。 经过个人观查当前的golang部分的服务代码，我发现单元测试存在的问题是: 测试用例不足，基本只有正常流程，即理想输入时的测试用例。 测试用例不够全面，边界值、特殊值、异常值、错误值输入无。 代码覆盖率不高，平均不超过40%。 没有一个规范的流程，基本是功能代码编写完后，才会开始编写单元测试。 没有需求文档、也没有针对需求文档的程序设计文档的编写与审核，基本上是口头传达需求，或者微信对需求，导致别人要的是马，你给人家的事骡子(大部分功能对上了，但是还是有些不同)。 个人能力不足，在此提一些自己的看法吧(规范性)，个人也会按照该看法进行开发。 开发一个功能前，理清并罗列需求，记录成一个TODO列表。 罗列并确认好需求后要进行代码设计如数据库表的设计，处理流程的设计，设计完后编写文档供相关工作同事对其合理性、正确性进行检查。检查完没问题了，才可以对照着文档进行测试与开发。(感觉这一步有点花费时间) 比如现在要接一个新渠道的广告，这里面涉及到的有广告点击回传处理、匹配上报处理2个大事件。拿广告点击回传举例，流程中从前往后涉及到了url参数解析函数、muid转换函数、BI日志打印函数、点击数据存库函数(此处有一个疑惑可以讨论，是对整个点击事件处理函数编写许多测试用例进行单元测试呢还是对每一个小的函数也编写测试函数进行单元测试，后者会不会带来工作量的大幅提升？待讨论)，目前的想法是对每个自己编写实现的小函数、方法都要编写其对应的单元测试，写对应函数的设计文档。 根据需求文档与设计文档编写测试函数，编写全面的测试用例与其对应的期望输出，编译不通过，编写该功能函数，循环，直至通过所有的测试用例。 针对测试用例不足。一定要写正常的、错误的、边界的 比如muid处理函数需要2个字符串参数，那么除了正常情况(一个有值，一个为空)外，测试用例可以写传入2个空串、传入2个有值的字符串、 "},"engineer/streesTest.html":{"url":"engineer/streesTest.html","title":"必要的压力测试","keywords":"","body":"必要的压力测试 "},"engineer/codeStyle.html":{"url":"engineer/codeStyle.html","title":"良好的代码规范","keywords":"","body":"良好的代码风格 "},"engineer/subjDoc.html":{"url":"engineer/subjDoc.html","title":"必要的项目文档","keywords":"","body":"详细的项目文档 ​ 文档一定要详细，比如一个接口的文档，得写应用场景即什么情况下会去调用这个接口、应用条件即接口须要怎么调用包括方法(get、post)，携带的参数( 类型、可选、必选 )、会返回什么值等等。 项目架构设计概要 包括前端使用框架、后端架构、数据库设计、前后端交互等等 关键功能设计 关键的功能模块函数、 业务逻辑概要 每一个模块的设计，比如用户中心设计 接口设计 包括接口功能、请求方法、请求参数、返回结果等等 数据库设计 包括每个库、每个表 一个示例项目文档示例： 一个开源的项目的设计文档 如何做好项目设计 自顶向下，层层细化 从整体到局部，不要过早陷入技术细节 分层、分模块。分层完后，基于之前的用例分析，将功能抽象成模块，如红包模块，发送红包可能需要鉴权，即鉴权模块。 API设计、数据库设计、模块设计 交流讨论验证优化设计 "},"engineer/codeReview.html":{"url":"engineer/codeReview.html","title":"必要的代码审核(CodeReview)","keywords":"","body":"必要的代码审查 参考文献/博客 谈程序的腐化 再谈谈代码规范的事 "},"KnowledgeSource/StrongerBlog.html":{"url":"KnowledgeSource/StrongerBlog.html","title":"大佬博客","keywords":"","body":"dalao 博客 ​ 大佬发布的博客往往干货很多，质量很高，是我们菜鸟的知识主要来源之地，故记录之，持续关注 Golang相关 面向信仰编程 Golang 博客有深度，很多都是从源码讲起，需要一定的基础 飞雪无情的博客 Golang 比较基础，知识点循序渐进，适合初级go程序员看 敬维 DevOps Golang 容器 Tony Bai Go程序员 鸟窝 大佬一个 Golang底层专栏 其他 阮一峰的网络日志 "},"KnowledgeSource/BigCompanyBlog.html":{"url":"KnowledgeSource/BigCompanyBlog.html","title":"大厂博客","keywords":"","body":"大厂发布的博客系列 ​ 很多大厂都有自己公开的博客，记录之，持续关注 后端 美团技术团队 阿里中间件团队 阿里云RDS-数据库内核组 阿里搜索事业部AI·OS搜索与推荐技术 前端 腾讯前端Alloy Team团队博客 其他 腾讯安全玄武实验室 360核心安全技术博客 "},"KnowledgeSource/BookLists.html":{"url":"KnowledgeSource/BookLists.html","title":"我的书单","keywords":"","body":"我的书单 2019计划 《代码整洁之道》 优秀开源的gitbook Nginx中文文档 微服务从设计到部署 Effective Go 中文版 the_way_to_go_Zh_Cn "},"ReadNotes/BeautyOfSoftwareEngineering/intro.html":{"url":"ReadNotes/BeautyOfSoftwareEngineering/intro.html","title":"软件工程之美","keywords":"","body":"该笔记为极客时间内的课程《软件工程之美》学习笔记。 一周完成一个大模块的学习，并做学习笔记与总结，最后给同事们做技术分享。 9月2号前完成 经典案例解析篇 的内容阅读。9月1号是周末。 经典案例解析篇 日期 备注 完成情况打卡 8月26 《为什么程序员的业余项目大多都死了》 完成 "},"DevOps/CI/CI.html":{"url":"DevOps/CI/CI.html","title":"CI","keywords":"","body":"CI ​ 什么是CI？CI是Continue Intergration 即持续集成的简写，那么什么又是持续集成呢？持续嘛，就是一直进行，集成嘛，就是把散装的东西合在一块成为一个可运行的整体。 ​ 持续集成就是分工合作的程序员在完成其部分功能模块代码并进行提交合并到代码仓库主分支的过程。提交上去的代码合并完之后能不保证在整体仍然是可运行、无bug(很理想)状态呢？最开始的做法是可以在服务器拉取最新代码到服务器机器上进行编译运行、测试等，通过了测试说明提交的代码没问题，否则就不能合并本次提交到主分支。想要达到持续及高效率状态，那么必然得实现这些流程(提交后)的自动化。实现每次提交代码自动触发服务器拉取代码，编译、测试等等。 原理： ​ 持续集成就是在向代码仓库提交代码后，会自动触发构建以及单元测试这两个动作，然后自动向开发团队反馈本次构建和测试的结果。 常见持续集成系统是 gitlab + jenkins + git,不过我们公司使用的是svn，所以得再调研svn的实现 必要条件： ​ 1. 版本控制的代码仓库，如git、svn ​ 2.持续集成系统，包括自动构建工具和自动触发单元测试工具 ​ 那么持续集成系统如何自动触发构建和单元测试动作呢？有一种解决方案是webhook，即设置自定义回调来增强或改变网页或web应用程序行为的方法。就是钩子嘛，钩子可以放在本地，也可以放在SVN服务端，只要有提交，就可以触发钩子内的代码，那么这个钩子该怎么写呢？ ​ 公司不知道允不允许我们在svn服务器上放钩子？有一个解决方案是我可以做一个任务编排系统，将写好的脚本编排成任务，放在测试或仿真服务器上，我们自己每次提交完代码后要去执行一下任务编排系统内的任务，该任务安排测试服去拉取代码，然后编译运行测试，将测试结果在发送给编排系统，如果成功了，那么就合并代码到主分支，如果失败了，则不作处理，所以此处可能要搞2个分支，一个为开发分支，一个为主分支。我们commit是commit到开发分支。通过CI后合并到主分支[不知道是否如此?]。 ​ 其实就是从代码库服务端检测到有commit后自动触发变为我们客户端commit完后手动调用任务编排系统去手动触发。 问题 既然CI要让没有通过测试的提交不能合并到主分支，那么它怎么让这次提交的代码与主分支代码合并后进行测试呢？ 2个分支，当我们commit后，代码库内的分支就已经是合并后的了，但是主分支还没合进去，所以我们拉取的是开发分支，测完再决定是否合并到主分支[不知道是否如此?]。 如果是钩子自动触发，那么这个钩子是放在客户端还是放在SVN服务端？放在客户端又得考虑不同的操作系统的钩子脚本？放在服务端的话允不允许？每个svn文件夹下都有个hook文件夹，可以存放钩子脚本。 首选在svn服务器放钩子 如果不使用钩子，而采用任务调度编排系统的话，得开发人员主动去启动任务，但是人往往是不可靠的，有可能会忘记。 方案 粗糙方案1 自己用golang写一个api服务(简单的任务编排调度系统)。该api服务提供一个接口，当svn收到一个commit时，自动触发这个提前写好的钩子脚本，钩子脚本请求该api(curl)，该api服务收到请求后执行一系列脚本，脚本1将开发分支代码拉取到其本地，脚本2执行项目中写好的编译脚本对拉取的代码进行编译，并运行；脚本3执行项目内写好的单元测试，如果通过测试，将开发分支代码合并到主分支，如果不同过，则revert到上一版本，并将执行结果通过某方式发送给任务调度系统，该系统将结果存储起来，在前端查询的时候进行返回展示。 流程 该方案几个关键点： 这一整套服务是部署在内网还是公网？先内网? 公司内网让不让在svn服务器上放钩子脚本？ 这个任务编排调度系统该怎么设计？先就实现一个接口？完成持续集成的功能？ 参考文档 持续集成之理论篇 devops实践二-持续集成持续交付 初创公司 CI 系统终极解决方案：Gitlab-CI 配置管理之持续集成 我所了解的几种持续集成方案 Travis CI教程-阮一峰 Docker — 从入门到实践 SVN钩子的书写 配置文件格式YAML "},"ToolsDoc/git/gitOp.html":{"url":"ToolsDoc/git/gitOp.html","title":"git","keywords":"","body":"Git操作指南 git rm 当在本地文件需要删除一些文件时，先删除，然后执行git rm xxx，如果是删除文件，则要加上 -r参数，然后提交 git commit -m \"remove something\"，因为删除也是一种修改，需要提交到版本库。 参考文章: git基本操作，一篇文章就够了 廖雪峰的git教程 "},"ToolsDoc/gitbook/gitbookOp.html":{"url":"ToolsDoc/gitbook/gitbookOp.html","title":"gitbook","keywords":"","body":"gitbook从头到尾 gitbook简明教程 GitBook插件整理 gitbook的 "},"ToolsDoc/Goland/goland.html":{"url":"ToolsDoc/Goland/goland.html","title":"Goland","keywords":"","body":"Goland实用操作指南 注释 ​ command + / 伸缩/展开函数 ​ command + . 好像不对 查找 ​ 在当前文件内查找: command + f ​ 在全局项目内查找: command + shift + f 另起一新行 ​ 在当前行下面另起一行(光标移到新行行首): shift + enter ​ 在当前行下面另起一行(光标不变): command + enter 跳出当前函数 Make Goland Great 先下载jar包JetbrainsCrack.jar，之前失效的下载最新的jar包，把它放到你认为合适的文件夹内，我直接放在了安装目录C:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.1\\bin。 JetbrainsCrack.jar下载地址： 某盘链接: https://pan.baidu.com/s/15-I7GmBSIjDpoQd4lkCeCQ 提取码: bmjq 划重点，修改配置文件：不能直接在bin目录下直接修改，先打开idea试用30天，然后点击你要注册的IDE菜单：“Help” -> “Edit Custom VM Options …”，如果提示是否要创建文件，请点\"是|Yes\"。 在打开的vmoptions编辑窗口末行添加：-javaagent:JetbrainsCrack.jar文件的绝对路径（一定要自己确认好路径，填错会导致IDE打不开！！！），不管是Mac、Linux、Windows都类似，都是绝对路径。 如我的路径: -javaagent:C:\\Program Files\\JetBrains\\IntelliJ IDEA 2019.1\\bin\\JetbrainsCrack.jar 重新启动你的IDEA。 注册\"Help\" -> “Register”，选择License server方式，地址填入：http://jetbrains-license-server （应该会自动填上） 看到Licensed to 用户名，即激活成功 可能会出现的问题： 8月完成的，但是9月第一天使用时，告诉我过期了，过期日期是8月31，折腾了半天，没弄好，重新进又显示无限期了。。。。。不明白其中原因。1没更新，2没重装。 "},"ToolsDoc/Markdown/Markdown.html":{"url":"ToolsDoc/Markdown/Markdown.html","title":"Markdown","keywords":"","body":"Markdown 反单引号 行内代码使用反引号 ` 来包裹 代码块使用3个反引号 ``` 来包裹,只能在新起的一行使用，并且打完3个反引号之后，可以指明是什么类型的代码。 mermaid 一个坑。就是每个alt都要有一个else和一个end对应。 问题 不同平台渲染效果不一 有时候用mac下的typora写的md文件，push到github上之后，显示出问题，初步推测是在mac下的typora输入时，符号与内容之间没有加空格。 参考文档 Typora官方文档 mermaid官方文档 "},"ToolsDoc/SublimeText/sublimeText.html":{"url":"ToolsDoc/SublimeText/sublimeText.html","title":"SublimeText","keywords":"","body":"Sublime Text操作大全 sublime text3格式化json "},"ToolsDoc/GreatJs/greatJs.html":{"url":"ToolsDoc/GreatJs/greatJs.html","title":"GreatJs","keywords":"","body":"好用的JavaScript插件 echarts 各种好看的图表 地址 echarts apiDoc 好用的api自动生成插件 地址： apiDoc nodeppt 直接将写好的md文件渲染成好看的ppt 号称 这可能是迄今为止最好的网页版演示库 地址： nodeppt "},"ToolsDoc/SVN/svn.html":{"url":"ToolsDoc/SVN/svn.html","title":"SVN","keywords":"","body":"SVN 操作记录 Remember 万事要先update，再commit。 "},"personalZone/personalWebSite.html":{"url":"personalZone/personalWebSite.html","title":"个人网站想法","keywords":"","body":"需求 ​ 有必要建立一个个人网站，内容包括技术博客、其他实用工具。应用微服务思维，网站为模块化，可以动态添加。一个模块为一个服务。多用户，每个用户有自己的模块。接口设计要遵循RESTful风格。数据库采用mongodb，缓存采用redis，消息队列使用nats streaming， 上述需求太虚、太笼统了。现新增一个需求 +2019年8月13日 先说最终结果是什么样的，就是像蚂蚁森林一样，种树，不过我们种的是技能树，比如说golang工程师、java工程师、钢琴家等等，那么想要实现这个技能树，那么少不了平时的努力，每一天的进步就会成为我们树苗的能量，当树苗的能量达到一定的数量时，树苗会长大，当我们达到了自己设下的目标后，这颗树也就变成了参天大树。需求大概如此。2019年8月13日立项。 需求设计 初步设计3张表， 用户表 描述 字段名 类型 示例 用户唯一id user_id string \"u15010110083\" 用户名 user_name string noobcoderr 用户邮箱 user_email string 用户创建的种子 seed_self []string [\"golang\",\"piano\"] 用户fork别人的种子 seed_other []string [\"java\",\"devops\"] 用户已完成的大树 user_trees []string [\"php\",\"python\"] 种子表 描述 字段名 类型 示例 种子名 seed_name string \"c++\" 种子唯一 ID seed_id string \"s15010110083\" 谁创建的种子 seed_creator string \"noobcoder\" 有多少人使用过该种子 seed_used_count int64 15 种子的标签 seed_tag []string [\"秃头\",\"程序员\",\"后端\",\"高并发\"] 是否被删除状态 seed_status int64 0:没被删除,1:被删除 种子描述 seed_desc string \"use it,you will stronger\" 种子阶段描述 seed_step_desc map[string][]string 每个阶段内部的小任务都放数组里 种子创建时间 seed_time_create int64 1560458730 种子库设计 可以有个人种子库，与公共种子库 可以动态增删改 可以往种子库里加种子，加种子操作第一个页面填写种子名与种子描述，第二个页面填写5个阶段的名字与描述，并再每个阶段内加小任务,并填些计划完成日期 查种子，可以根据种子名、种子唯一id、种子标签等进行查询 删除只能删除自己创建的，删除之前询问，有xx人使用过它，确定要删除它？ 改的话，除了唯一id，其他都可以修改。 有点像github的仓库。 8-13定下目标，先写个人模块，包括登陆注册注销修改密码。。。。还得设计这个模块。。。 依赖 echo vue goframe "},"work/redisLock.html":{"url":"work/redisLock.html","title":"Redis锁","keywords":"","body":"redis锁的可用性简单测试(2019-7-23) 测试工具 ​ antarmy 背景介绍 ​ 手Q accesstoken获取服务，当redis内没有accesstoken的时候，会获取一把锁，然后再调用qq提供的接口去请求新的accesstoken，获取完并存入redis后再释放该锁。 测试方法 ​ 将accesstoken的有效期设置为10秒，在过期前用antarmy制造每秒2000并发请求该接口 测试结果 ​ 经过测试，返回的accesstoken只有2个，即没过期前的和过期后第一个获得锁的协程请求到的那个accesstoken，即锁是可用的正确的。 收获 ​ 今天才知道redis是单进程单线程的，即一个任务处理完才能处理下一个，那么 "},"unitTest/utdoc.html":{"url":"unitTest/utdoc.html","title":"单元测试文档","keywords":"","body":"以我在刚写单元测试经历的过程为路径进行分享:happy: 关于单元测试 什么是测试？ ​ 测试，即对完成的工作进行功能正确性检验的活动。该检验通过对被测对象提供合法(正常情况，极端情况，边界情况)以及不合法的输入(所有可能发生的情况)，并通过比较预期输出与实际输出内容是否相等或者在误差范围内，来达到检验正确性的目的。单元测试就是对代码组织的最小单元进行的测试。 为什么要做单元测试。 ​ 为了保证我们写的代码一直(包括初次完成以及之后的所有修改)是功能正确的。一个函数对应一个功能，所以当其对应的测试代码完成后，所有情况的输入都有了预期的输出，当对代码进行改动后，如果得到的输出不符合测试代码的预期输出，那么说明此次代码的改动出了问题。当然，也为别人可以很快的通过测试代码了解代码的逻辑以及实现的功能。尽早发现问题、bug。 哪些代码需要进行单元测试？ 逻辑复杂的 容易出错的 不易理解的，即过段时间自己也会忘记的，看不懂的，单元测试代码有助于理解代码的功能和需求 公共代码。大家都会调用的公共方法类 核心业务代码。 单元测试的难点 测试粒度 ​ 粒度太细，会耗费大量开发时间及维护时间，粒度太粗，一个测试函数测试了很多方法，则显得臃肿，变成了集成测试。当然这中间有个度，该如何掌握，则考验我们积累的经验了。 如下测试函数测试了增删改查4个函数,查询函数依赖于插入函数先往数据库中插入数据 func TestAdvClientIdDao_AddCid(t *testing.T) { dao := &AdvClientIdDao{} defer dao.Close() client_id := \"ios_android\" err := dao.UpsertClientId(client_id) assert.Empty(t, err) bean, err := dao.FindClientId(client_id) assert.Empty(t, err) assert.Equal(t, \"ios_android\", bean.ClientId) beans, _, err := dao.QueryCid(client_id, 0) assert.Empty(t, err) for _, data := range *beans { assert.Equal(t, \"ios_android\", data.ClientId) } err = dao.DeleteCid(client_id) assert.Empty(t, err) } 破除外部依赖(mock,stub技术) ​ 单元测试一般不允许有任何外部依赖（文件依赖，网络依赖，数据库依赖等），我们不会在测试代码中去连接数据库，调用api等。这些外部依赖在执行测试的时候需要被模拟(mock/stub)。在测试的时候，我们使用模拟的对象来模拟真实依赖下的各种行为。如何运用mock/stub来模拟系统真实行为算是单元测试道路上的一只拦路虎。 ​ 有的时候模拟是有效的方便的。但我们要提防过度的mock/stub，因为其会导致单元测试主要在测模拟对象而不是实际的系统。 合格的单元测试 所有独立执行通路测试：保证每一行代码，每个分支都经过了测试 代码覆盖率 语句覆盖：保证每一条语句都执行到了 判定(分支)覆盖：保证每一个分支都覆盖到 条件覆盖：保证每一个条件都覆盖到(true/false) 路径：保证每一个路径都覆盖到 各条错误处理条件通路测试：保证每一个异常都经过测试 边界条件测试 变量没有赋值( 值为nil ) 变量数数值 正常边界：最小值、最大值、无穷大 临近边界：比最小值大1、比最大值小1 溢出边界：比最大值大1、比最小值小1 变量是字符串 空字符串 引用字符串边界索引 str [ len( str ) + 1 ] 变量有规律 独立性，测试用例的的数据不依赖其他输出，减少相互影响。 关于测试用例 测试用例的情况 测试用例要尽可能覆盖方法可能出现的情况，常见的情况有： 正常用例，即走最多数情况的正常测试 错误用例，即会令程序出现错误的分支 分支用例，即多个分支的情况都要考虑到的测试 边界值用例，即考虑输入的边界值的测试 测试用例组织技巧 ​ 表格驱动测试 table driven ​ 前提是：这一系列的用例的断言逻辑都一样。 func TestAdd(t, *testing.T){ Caese := []struct{ name string first int second int expect int }{ //此处填写多测试用例 { name:\"positiveNum\", first:1, second:2, expect:3, }, { name:\"negativeNum\", first:-1, second:-2, expect:-3, }, } //遍历执行测试用例 for _,Case := range Cases { t.Run(Case.name,func(t *testing.T){ actual := Add(Case.expect) assert.Equal(t,Case.expect,actual) }) } } ​ 这种组织方法的好处是将容易变化的消息和不容易变化的逻辑分离，使更加清晰和简练，减少了复制粘贴，并大大提高的测试代码的可读性。 成本/价值 依赖很少的简单的代码(左下) 依赖较多但是很简单的代码(右下) 依赖很少的复杂代码(左上) ​ 独立的复杂算法（银行利息计算，保险费率计算，TCP协议解析等），像这一类代码外部依赖很少，但却很容易出错，单元测试最有价值 依赖很多又很复杂(右上) ​ 像这种代码我们尽量在设计上将其分为两部分：1.处理复杂的逻辑部分 2.处理依赖部分 然后1部分进行单元测试 单元测试第一步 依赖 ​ 所谓依赖，就是A函数中会调用B，但是B不受A的控制，反而会影响A的进程，即如果B出错了，那么会导致A直接失败。如下函数中HandlePush中的依赖为rptdao。 type AiClk struct { } func (this *AiClk) HandlePush(data mgotools.CallbackDataBean, extra map[string]string, logger *utils.Logger) { //... //修改状态 rptdao := &mgotools.EventReportDao{ CloudId: data.CloudId, } defer rptdao.Close() err = rptdao.FindAndModify(data.MuId, data.ClientId, data.AdvPlatform, extra) //... } 识别程序中的外部依赖 ​ 常见的外部依赖有： 网络依赖-函数执行依赖于网络请求，如第三方http-api(归因数据上报到广告平台)、消息队列(匹配到的数据发到消息队里里去处理)、rpc等 数据库依赖-各个数据库的dao结构体 I/O依赖 未完成开发的功能模块 处理方法 抽象成接口，通过mock和stub进行模拟测试 A依赖B， 所以要在A的构造函数里面把B丢进去，而不是在A内部生成B。 ​ 接口需要以依赖注入的方式注入到结构体中，这样才能为测试提供替换接口实现的可能，所谓依赖注入为一个类或者函数A，用到内部对象B，B在A的外部创建，当运行A调用B时，通过某种方式将外部创建的B的实例赋给A内的B。这样当A调用B时，B就会按照外部定义的方式去运行。 ​ 除了依赖注入，另一种mock实现是通过go语言的interface，被mock的对象需要继承interface,并在interface中定义好被mock对象的方法。mock对象通过实现interface的所有方法来表明自己实现了这个interface，这样mock对象的值就可以替换被mock对象的值。 Mock 当数据库还不可用，或者无网络连接，那么可以通过模拟这些依赖来达到测试程序逻辑 Mock：在测试包中创建一个结构体，满足某个外部依赖的接口 ​ mocks 在测试无状态函数中意义不大，其应用场景主要在于处理不可控的第三方服务、数据库、磁盘读写等。如果这些服务的调用细节已经被封装到 interface 内部，调用方只看到了 interface 定义的一组方法，那么在测试中 mocks 就能控制第三方服务返回任意期望的结果，进而实现对调用方逻辑的全方位测试。 使用依赖注入传递接口 ​ 先看一段代码 type AiClk struct { } func (this *AiClk) HandlePush(data mgotools.CallbackDataBean, extra map[string]string, logger *utils.Logger) { //... //修改状态 rptdao := &mgotools.EventReportDao{ CloudId: data.CloudId, } defer rptdao.Close() err = rptdao.FindAndModify(data.MuId, data.ClientId, data.AdvPlatform, extra) //... } ​ rptdao完全在内部独立实现，无法操作其行为。这使得我们的测试很难去除这块依赖。 ​ 将该数据库依赖抽象成接口后 type RptDao interface{ FindAndModify(a,b,c string,map[string]interface{}) } type AiClk struct { dao RptDao } // NewAiclk, 通过构造函数的方式，将RptDao接口注入 func NewAiclk(dao RptDao) *AiClk { return &AiClk{dao:dao} } func (this *AiClk) HandlePush(data mgotools.CallbackDataBean, extra map[string]string, logger *utils.Logger) { this.dao.FindAndModify() } dao在外部实现，达到可以控制的目的。 总结 ​ 单测的主要步骤 识别依赖 将依赖抽象成接口 使用依赖注入的方式将接口注入 提高工作效率，单元测试工具(testing+testify+gomock+httptest+httpmock)接入 testing Go语言中自带有一个轻量级的测试框架testing和自带的go test命令来实现单元测试。原则： 文件名必须是_test.go结尾的，这样在执行go test的时候才会执行到相应的代码 测试用例函数必须是Test开头 测试函数TestXxx()的参数是testing.T testify ​ 引入断言能为我们提供便利——提高测试效率，增强代码可读性.其中每个断言函数第一个参数都为* testing.T对象，这样我们才可以通过该对象跟踪测试中出错的地方。assert包出错不会中断测试继续。 断言表达式 描述 assert.Equal(t,a,b) 断言传入的预期值a与实际值b是相等的 assert.NotEqual() assert.Nil(t,b) 实际值为Nil assert.NotNil(t,a) assert.Empty(t,b) 实际值为空 assert.NotEmpty(t,a) assert.Zero(t,b) 实际值为0 assert.NotZero(t,a) assert.True(t,b) 实际值为true assert.False(t,a) assert.Error(t,b) 实际值为false assert.NoError() assert.Regexp(t,rx,str) 能用rx从str中匹配到数据 gomock ​ google开源的golang测试框架，自动生成mock对象。 示例： package gdtMock type GDTClk struct { Operate Operate } type Operate interface { //一系列查询操作的方法接口，多个平台都会用到 Find() FindAndModify(a string) string Query() Delete() } func NewGDTClk(op Operate) *GDTClk { if op != nil { return &GDTClk{ Operate:op, } } else { return &GDTClk{ } } } func (gdt *GDTClk)HandlePush(a string) string { //先打BI日志 //更改数据库状态 rst := gdt.Operate.FindAndModify(a) //进行上报请求 return rst } 使用步骤： 将想要mock的对象抽象成接口后，通过mockgen命令自动生成目标对象的mock对象 mockgen -source gdt.go -destination gdtMock.go -package gdtMock 该命令将gdt.go内部的接口interface{}全部mock出mock对象并存储在gdtMock.go文件中，指定存放mock对象的包名为gdtMock，生成的文件内容如下： // Code generated by MockGen. DO NOT EDIT. // Source: gdt.go // Package gdtMock is a generated GoMock package. package gdtMock import ( gomock \"github.com/golang/mock/gomock\" reflect \"reflect\" ) // MockOperate is a mock of Operate interface type MockOperate struct { ctrl *gomock.Controller recorder *MockOperateMockRecorder } // MockOperateMockRecorder is the mock recorder for MockOperate type MockOperateMockRecorder struct { mock *MockOperate } // NewMockOperate creates a new mock instance func NewMockOperate(ctrl *gomock.Controller) *MockOperate { mock := &MockOperate{ctrl: ctrl} mock.recorder = &MockOperateMockRecorder{mock} return mock } // EXPECT returns an object that allows the caller to indicate expected use func (m *MockOperate) EXPECT() *MockOperateMockRecorder { return m.recorder } // FindAndModify mocks base method func (m *MockOperate) FindAndModify(a string) string { m.ctrl.T.Helper() ret := m.ctrl.Call(m, \"FindAndModify\", a) ret0, _ := ret[0].(string) return ret0 } // FindAndModify indicates an expected call of FindAndModify func (mr *MockOperateMockRecorder) FindAndModify(a interface{}) *gomock.Call { mr.mock.ctrl.T.Helper() return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindAndModify\", reflect.TypeOf((*MockOperate)(nil).FindAndModify), a) } 编写测试代码 func TestGDTClk_HandlePush(t *testing.T) { //mock时候的测试 ctrl := gomock.NewController(t) defer ctrl.Finish() mockOp := NewMockOperate(ctrl) mockOp.EXPECT().FindAndModify(\"abc\").Return(\"success\") clk := NewGDTClk(mockOp) assert.Equal(t,\"success\",clk.HandlePush(\"abc\")) } 语句说明: gomock.NewController：返回 gomock.Controller，它代表 mock 生态系统中的顶级控件。定义了 mock 对象的范围、生命周期和期待值。另外它在多个 goroutine 中是安全的 ctrl.Finish()：进行 mock 用例的期望值断言，一般会使用 defer 延迟执行，以防止我们忘记这一操作 mock.NewMockOperate：创建一个新的 mock 实例 gomock.InOrder：声明给定的调用应按顺序进行（是对 gomock.After 的二次封装） mockOp.EXPECT().FindAndModify().Return(nil)：这里有三个步骤，EXPECT()返回一个允许调用者设置期望和返回值的对象。FindAndModify()是设置入参并调用 mock 实例中的方法。Return(nil)` 是设置先前调用的方法出参。简单来说，就是设置入参并调用，最后设置返回值 NewGDTClk(mockOp)：创建 GDTClk实例，值得注意的是，在这里注入了 mock 对象，因此实际在随后的 gdt.HandlePush 调用中。它调用的是我们事先模拟好的 mock 方法 常用 mock 方法 Call.Do()：声明在匹配时要运行的操作 Call.DoAndReturn()：声明在匹配调用时要运行的操作，并且模拟返回该函数的返回值 Call.MaxTimes()：设置最大的调用次数为 n 次 Call.MinTimes()：设置最小的调用次数为 n 次 Call.AnyTimes()：允许调用次数为 0 次或更多次 Call.Times()：设置调用次数为 n 次 参数匹配 gomock.Any()：匹配任意值 gomock.Eq()：通过反射匹配到指定的类型值，而不需要手动设置 gomock.Nil()：返回 nil httptest web开发 handlerfunc测试利器 如果需要测试handlers接口函数的话，主要可以采用两种方式来进行。 第一种是部署web server，然后通过浏览器或其他http请求模拟工具来手动模拟真实的http请求，发送http请求之后，解析返回的响应，查看响应是否符合预期；这种做法比较麻烦，而且测试结果不太可靠。 第二种是使用httptest结合testing来实现针对handlers接口函数的单元测试。 func TestAiclkController_HandleCallback(t *testing.T) { URL := \"http://127.0.0.1:8080/report_ad_event/v1/aiclk/callback.json?cid=123&os=1&imei=__IMEI__&imei_md5=__IMEIMD5\" + \"__&idfa=A1A5B766-712D-4267-B9B5-7CD9D1C86C30&timestamp=12345&callback_url=https%3a%2f%2fwww.test.com&\" + \"unit=1111&plan=2222&android_id=__ANDROIDID__&uid=333&params=YWN0TmFtZT11bml0X3Rlc3QmYWRzVHlwZT0wMDAmYXBw\" + \"SWQ9MDAwJmNoYW5uZWw9dGVzdENoYW5uZWwmY2xpZW50SWQ9dHkudXQ=\" req, err := http.NewRequest(\"GET\", URL, nil) if err != nil { t.Fatal(err) } req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON) // 我们创建一个 ResponseRecorder (which satisfies http.ResponseWriter)来记录响应 rr := httptest.NewRecorder() ectest.ServeHTTP(rr, req) // 检测返回的状态码 assert.Equal(t, 200, rr.Code) // 检测返回的数据 assert.Regexp(t, regexp.MustCompile(`\"code\":0`), rr.Body.String()) } ​ httpmock ​ httpmock采用模式匹配的方法匹配HTTP请求的URL，在匹配到特定的请求时就会返回预先 设置好的响应。 func (gdt *GDTClk)HandlePush(a string) string { //先打BI日志 //依赖1：查库更改 rstDB := gdt.Operate.FindAndModify(a) if rstDB == \"fail\" { return \"fail\" } fmt.Println(rstDB) //依赖2：组装url上报 URL := \"http://127.0.0.1:8080/report?params=a1b2c3d4e5f6\" resp,err := http.Get(URL) defer resp.Body.Close() if err != nil { return fmt.Sprintf(\"get err %v\",err) } if resp.StatusCode != http.StatusOK { return fmt.Sprintf(\"status code want 200 but get %v\",resp.StatusCode) } bodyBytes, _ := ioutil.ReadAll(resp.Body) rstHttp := new(RetMsg) err = json.Unmarshal(bodyBytes, &rstHttp) if err != nil { logs.Error(\"decode data fail\") return \"umashal error\" } fmt.Println(fmt.Sprintf(\"http mock %v\",rstHttp.Message)) return \"success\" } func TestFetchArticles(t *testing.T) { httpmock.Activate() defer httpmock.DeactivateAndReset() httpmock.RegisterResponder(\"GET\", \"http://127.0.0.1:8080/report?params=a1b2c3d4e5f6\", httpmock.NewStringResponder(200, `[{\"status\": 801, \"message\": \"invalid timestamp\"}]`)) //RESTful风格的正则匹配 httpmock.RegisterResponder(\"GET\", `=~^https://api\\.mybiz\\.com/articles/id/\\d+\\z`, httpmock.NewStringResponder(200, `{\"status\": 200, \"message\": \"miss event_type\"}`)) //HandlePush的内部会有http请求，会被httpmock捕获，然后返回设置好的响应内容。 rst := HandPush(\"\") assert.Equal(t,\"success\",rst) } 正则匹配，当请求http://127.0.0.1:8080/report?params=a1b2c3d4e5f6时，以下匹配式可以被捕获： 完整的原始URL http://127.0.0.1:8080/report?params=a1b2c3d4e5f6 没有查询参数的 http://127.0.0.1:8080/report 没有协议和域名 /report?params=a1b2c3d4e5f6 只有路径 /report 带请求参数时，参数经过排序。b=1&a=2 => a=2&b=1 启示 ​ 要写易测的代码。隔离好依赖。使用接口interface、通过复合(嵌入)构造高层接口,书写优雅的golang代码。 ​ interface{}主要应用在当一个函数处理多种结构体时，将参数设置为interface{},或者一个包含某些方法的interface，那么实现了参数设置的接口的其他类型就可以传进来了。在内部进行类型断言就可以调用对应的方法了。 ​ 参考代码，广告上报服务中src/adsmatch/module.go内204行 ad.(AdsModel).HandlePush(result, ExtraSDK, logger),每个渠道都实现了AdsModel接口，则此时通过类型断言就可以得到其存储的具体类型的值了。 拓展 stub redis stub MySQL DI依赖注入。 单元测试的before/after before：进行单元测试时，很重要的一点是保证之前测试的遗留数据或者实例得到销毁，新测试的状态是重建的，就好像之前没有测试运行过一样。 为什么要mock ​ 一旦测试依赖了文件系统，你进行的就是集成测试，带来了所有集成测试相关的问题————运行速度慢，需要配置等等 区分单元测试和集成测试 任何测试，如果它运行速度不快，结果不稳定，或者要用到被测试单元的一个或多个真实依赖物，我就认为它是集成测试。集成测试是对一个工作单元进行的测试，这个测试对被测试的工作单元没有完全的控制，并使用该单元的一个或多个真实依赖物，例如事件、网络、数据库、线程或随机数产生器等。 参考文献或博客： golang代码书写规范 如何写出优雅的golang代码 golang设计模式 实用go语言单元测试中的接口及其复合（一） golang官方书写规范 gomock golang单元测试实践 单元测试的理解 单元测试用例编写总结 浅析Mock，Fake和Stub在测试中的应用 Gopher 上手指南：第十一期 浅谈测试驱动开发TDD 单元测试mock模块介绍 云平台下Go语言单元测试实践 Golang 单元测试框架 gocheck 使用介绍 gomock 搞定golang单元测试--mock框架 gocheck golang项目的测试实践 实用go语言单元测试中的接口及其复合（一） 阿里巴巴Java开发者手册-单元测试) httptest Golang单元测试之httptest使用 Testing Your (HTTP) Handlers in Go golang web开发 Handler测试利器httptest 依赖注入 golang中的依赖注入 依赖注入Wire interface 理解 Go interface 的 5 个关键点 "},"CS/Heap&Stack.html":{"url":"CS/Heap&Stack.html","title":"堆/栈","keywords":"","body":"堆(Heap)与栈(Stack) 栈：用于维护函数调用的上下文。 堆：用来容纳应用程序动态分配的内存区域，当使用malloc或者new分配内存时，得到的内存来自堆里。 参考文献/博客 深入了解堆与栈(https://blog.csdn.net/u014608280/article/details/82218079) 什么是堆栈，他们在哪儿(https://blog.csdn.net/qq_35396127/article/details/80397048) 堆(Heap)与栈(Stack)的区别(https://blog.csdn.net/qq_15897815/article/details/81808927) "},"ReadNotes/BeautyOfSoftwareEngineering/BasicTheory.html":{"url":"ReadNotes/BeautyOfSoftwareEngineering/BasicTheory.html","title":"基础理论","keywords":"","body":"基础理论篇 "},"ReadNotes/GoInAction/intro.html":{"url":"ReadNotes/GoInAction/intro.html","title":"Go实战","keywords":"","body":"《Go实战》读书笔记 "}}